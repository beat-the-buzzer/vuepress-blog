(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{319:function(e,t,r){"use strict";r.r(t);var v=r(14),a=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),t("h2",{attrs:{id:"mvvm-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-是什么"}},[e._v("#")]),e._v(" MVVM 是什么？")]),e._v(" "),t("p",[e._v("MVVM，即 Model–View–ViewModel，是一种软件架构模式。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Model\n即模型，是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。")])]),e._v(" "),t("li",[t("p",[e._v("View\n即视图，是用户在屏幕上看到的结构、布局和外观（UI）。")])]),e._v(" "),t("li",[t("p",[e._v("ViewModel\n即视图模型，是暴露公共属性和命令的视图的抽象。用于把 Model 和 View 关联起来。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model 。")])])]),e._v(" "),t("p",[e._v("在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。")]),e._v(" "),t("h2",{attrs:{id:"vue-响应式系统的原理是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-响应式系统的原理是什么"}},[e._v("#")]),e._v(" Vue 响应式系统的原理是什么？")]),e._v(" "),t("p",[e._v("Vue 实现响应式主要是采用数据劫持结合发布者-订阅者模式的方式。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Observer：对数据对象的所有属性进行监听，当把一个普通对象传给 Vue 实例的 data 选项时，Observer 将遍历它的所有属性，并为其添加 getter 和 setter。getter 将收集此属性所有的订阅者，setter 将在属性发生变动的时候，重新为此属性赋值，并通知订阅者调用其对应的更新函数。")])]),e._v(" "),t("li",[t("p",[e._v("Compiler：模板编译器。它的作用是对每个元素节点的指令 v- 和模板语法 {{}} 进行扫描，替换对应的真实数据，或绑定相应的事件函数。")])]),e._v(" "),t("li",[t("p",[e._v("Watcher：作为连接 Observer 和 Compiler 的桥梁，能够订阅并收到每个属性变动的通知，然后执行相应的回调函数。Compiler 在编译时通过 Watcher 绑定对应的数据更新回调函数，Observer 在监听到数据变化时执行此回调。在 Observer 中，Watcher 就是订阅者，在 Compiler 中，Watcher 就是发布者。")])])]),e._v(" "),t("h2",{attrs:{id:"vue父子组件的生命周期有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue父子组件的生命周期有哪些"}},[e._v("#")]),e._v(" Vue父子组件的生命周期有哪些")]),e._v(" "),t("h2",{attrs:{id:"vue组件之间如何传值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue组件之间如何传值"}},[e._v("#")]),e._v(" Vue组件之间如何传值")]),e._v(" "),t("h2",{attrs:{id:"vue-router-hash模式和history模式分别是什么原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-hash模式和history模式分别是什么原理"}},[e._v("#")]),e._v(" Vue-Router hash模式和history模式分别是什么原理？")]),e._v(" "),t("h2",{attrs:{id:"vue3相比vue2-做了哪些提升"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3相比vue2-做了哪些提升"}},[e._v("#")]),e._v(" Vue3相比Vue2，做了哪些提升")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Vue2的Vue是一个构造函数，Vue3是输出了很多函数，对于全局api，比如nextTick，Vue2会挂在实例上，而Vue3是需要的时候再去引用；\n这种设计方式更加方便"),t("code",[e._v("tree shaking")]),e._v("。\n没有用到的函数不会参与打包，可以减小包的体积，并且提升打包速度；")])]),e._v(" "),t("li",[t("p",[e._v("Vue3推荐使用组合式Api，可以把相关联的逻辑写在一起，就像Vue文件一样，把一个小模块的html/css/js都整合在一起；\n而Vue2的data和methods在代码层面看不出关联关系。")])]),e._v(" "),t("li",[t("p",[e._v("响应式原理的变化：")])])]),e._v(" "),t("p",[e._v("Vue2是使用defineProperty去遍历对象的属性，对数据进行劫持，然后通过发布订阅模式，去维护视图和UI的关系；\nVue3使用proxy进行代理，相当于直接去操作数据，因此不存在遍历属性的操作，性能会更高。")]),e._v(" "),t("p",[e._v("Vue2对数组方法的重写；\nVue2对对象新增属性的实时更新；\n这些问题都在Vue3中被解决了；")]),e._v(" "),t("p",[e._v("因此Vue3的兼容性，完全抛弃了不支持“proxy”的浏览器；")]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("p",[e._v("Vue3封装hooks，取代vue2中的mixin，提升代码的可维护性、解决命名冲突等等")])]),e._v(" "),t("li",[t("p",[e._v("多根节点、teleport传送、createReanderer自定义渲染器")])]),e._v(" "),t("li",[t("p",[e._v("虚拟DOM新增静态标记，diff计算时忽略")])]),e._v(" "),t("li",[t("p",[e._v("更好地支持TS")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);